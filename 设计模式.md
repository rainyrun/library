# 设计模式

设计原则

1. 把需要变化的代码从稳定的代码中抽离出，并封装起来，以便以后可以轻易地改动或扩充。
2. 针对接口编程，而不是针对实现编程
3. 多用组合，少用继承
4. 为了交互对象之间的松耦合设计而努力
5. 类应该对扩展开放，对修改关闭。（但每个地方都采用开放-关闭原则，则是一种浪费，也没必要，会导致代码变得复杂且难以理解。）
6. 要依赖抽象，不要依赖具体类
7. 最少知识(Least Knowledge)原则：只和你的密友谈话。
8. 好莱坞原则：别调用我们，我们会调用你。
9. 一个类应该只有一个引起变化的原因

## 策略模式 Strategy Pattern

定义了算法族（通过接口），分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。

## 观察者模式

Subject(主题) + Observer(观察者)

主题是拥有数据的对象，观察者是使用数据的对象。一个主题对应多个观察者。当数据有关变化时，主题将通知观察者们。任何时候都可以增加新的观察者，因为主题唯一依赖的是一个实现Observer接口的对象列表。

```java
interface Subject {
    void registerObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObservers();
}

interface Observer {
    void update(...);
}

// java内置的主题和观察者
java.util.Observer // 观察者
java.util.Observable // 主题（是个类）
```

## 装饰者模式

- 装饰者和被装饰对象有相同的超类型
- 可以用一个或多个装饰者包装一个对象
- 因为有相同的超类型，可以用装饰过的对象代替原始对象（被装饰的对象）
- 装饰者可以在所委托被装饰者的行为之前/之后，加上自己的行为，达到特定的目的。
- 对象可以在任何时候被装饰。

java.io类中有很多装饰者模式

类结构

```
      超类（抽象类）
 |                 | 
组件          装饰者类（抽象类）
             |     |     |
        装饰者1   装饰者2   装饰者3
```

使用场景：二次开发时，无法获取到源码，无法继承时，需要对象的方法进行增强。

弊端：方法过多时，冗余

## 工厂模式

1. 简单工厂模式

将创建对象的任务，放在一个类的某个方法（通常是静态方法）里。

2. 工厂方法模式

定义：工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

工厂方法模式(Factory Method Pattern)通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。

- 创建者(Creator)类：定义抽象的工厂方法，让子类实现此方法。
- 产品类：工厂生产产品

用来处理对象的创建，并将这样的行为封装在子类中。

```java
abstract class Creator{
    abstract Product factoryMethod(String type){}
    void anOperation(){}
}
class ConcreteCreator extends Creator{
    Product factoryMethod(String type){
        // 实际制造出产品
    }
}
abstract class Product{
    // some method
}
class ConcreteProduct extends Product{}
```

3. 抽象工厂模式

定义：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

```java
interface AbstractFactory {
    createProductA();
    createProductB();
}
class ConcreteFactory1 implements AbstractFactory {}
```

## 单例模式 Singleton Pattern

定义：确保一个类只有一个实例，并提供一个全局访问点。

```java
public class Singleton {
    private static Singleton uniqueInstance;
    private Singleton(){}
    public static Singleton getInstance(){
        if(uniqueInstance == null)
            uniqueInstance = new Singleton();
        return uniqueInstance;
    }
}
```

但多线程的时候，可能会产生多个实例。

加 sychronized 关键字，又会降低性能，且只有在第一次创建实例的时候，才需要同步。解决方法如下

1. 性能问题影响不大，就使用 sychronized 关键字
2. 提前创建实例 `private static Singleton uniqueInstance = new Singleton();`
3. 利用“双重检查加锁”

```java
// 双重检查加锁
public class Singleton {
    private volatile static Singleton uniqueInstance; // volatile确保当实例被创建时，多个线程能正确获得uniqueInstance的状态。
    private Singleton(){}
    public static Singleton getInstance(){
        if(uniqueInstance == null){
            synchronized (Singleton.class){
                if(uniqueInstance == null)
                    uniqueInstance = new Singleton();
            }
        }
        return uniqueInstance;
    }
}
```

## 命令模式

定义：将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

我的理解：将一系列的动作封装到命令对象的execute方法中，当请求到来时，直接执行execute方法，就能得到想要的结果。

```java
public interface Command {
    void execute();
    void undo();
}

public class ConcreteCommand implements Command {
    Receiver receiver;
    public ConcreteCommand(Receiver receiver){
        this.receiver = receiver;
    }
    public void execute() {
        receiver.action();
    }
}

public class Receiver {
    public void action(){}
}
```

## 适配器模式

将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

```java
class Client{
    Target target;
}
interface Target {
    request()
}
// 对象适配器，采用组合的方式
class Adapter implements Target {
    Adaptee adaptee;
    request(){
        adaptee.action();
    }
}
class Adaptee{
    action(){}
}
// 类适配器，采用多继承的方式
class Adapter2 extends Adaptee implements Target {
    request(){
        action();
    }
}
```



## 外观模式 Facade Pattern

定义：提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高级接口，让子系统更容易使用。

提供简化的接口，将客户从组件的子系统中解耦

## 模板方法模式

模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。

定义：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

```java
abstract class AbstractClass {
    final void templateMethod(){
        primitiveOperation1();
        primitiveOperation2();
        concreteOperation();
        if(hook()){
            // doSomthing
        }
    }
    abstract void primitiveOperation1();
    abstract void primitiveOperation2();
    void concreteOperation(){}
    // 默认不做事的方法，子类覆写后，可以用来控制模板方法
    boolean hook(){
        return true;
    }
}
class ConcreteClass extends AbstractClass {
    
}
```

## 迭代器模式 Iterator Pattern

定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

```java
interface Aggregate {
    createIterator()
}
class ConcreteAggregate implements Aggregate {
    createIterator()
}
interface Iterator {
    hasNext();
    next();
    remove();
}
class ConcreteIterator implements Iterator {
}
```

## 组合模式

定于：允许将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。

```java
abstract class Component {
    operation()
    add(Component)
    remove(Component)
    getChild(int)
}
class Leaf extends Component {}
class Composite extends Component {}
```

## 状态模式

定义：允许对象在内部状态改变时，改变它的行为，对象看起来好像修改了它的类。

我的理解：一个对象有很多种状态和固定的动作，将每个状态封装成一个类，状态在动作下可能发生的变化写成类的方法。

```java
class Context {
    State state;
    request(){
        state.handle();
    }
}
interface State {
    handle()
}
class ConcreteStateA implements State {
    handle(){}
}
class ConcreteStateB implements State {
    handle(){}
}
```

## 代理模式

定义：为另一个对象提供一个替身或占位符以控制对这个对象的访问

1. 远程代理：管理客户和远程对象之间的交互。参考笔记“Java基础”里的RMI部分
2. 虚拟代理：作为创建开销大的对象的代表。虚拟代理直到我们真正需要一个对象的时候才创建它。
3. 保护代理：基于调用者控制对对象方法的访问

使用代理模式创建代表(representative)对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象，创建开销大的对象或需要安全控制的对象。

```java
interface Subject {
    request()
}
class RealSubject implements Subject {
    request()
}
class Proxy implements Subject {
    RealSubject subject;
    request(){
        subject.request();
    }
}
```

动态代理

参考笔记“Java基础”里的Proxy类

```java
interface Subject {
    request()
}
class RealSubject implements Subject {
    request()
}
class Proxy implements Subject {
    InvocationHandler handler;
    request(){
        handler.invoke();
    }
}
class InvocationHandler implements InvocationHandler {
    RealSubject subject;
    invoke(){
        subject.request();
    }
}
interface InvocationHandler {
    invoke();
}
```

## 复合模式 Compound Pattern

定义：结合两个或两个以上的模式，组成一个解决方案，解决一再发生的一般性问题。

MVC模式

- 视图：用来呈现模型。视图通常直接从模型中取得它需要显示的状态与数据
- 控制器：取得用户输入，并解读其对模型的意思
- 模型：持有所有的数据、状态、程序逻辑。模型没有注意到视图和控制器，虽然它提供了操纵和检索状态的接口，并发送状态改变通知给观察者。

使用到的模式

1. 观察者模式：模式是主题(or可观察者)，视图、控制器是观察者
2. 策略模式：视图可以使用控制器提供的不同策略
3. 组合模式：视图内部管理组件，使用的是组合模式（Swing）

## 模式

根据模式的目标分成三个不同的类目

1. 创建型：涉及到将对象实例化，这类模式都提供一个方法，将客户从所需要实例化的对象中解耦。
    - 抽象工厂 Abstract Factory
    - 工厂方法 Factory Method
    - 单例 Singleton
    - Builder
    - Prototype
2. 行为型：涉及到类和对象如何交互及分配职责。
    - 状态 State
    - 观察者 Observer
    - 策略 Strategy
    - 迭代器 Iterator
    - 模板方法 Template Method
    - Visitor
    - Mediator
    - 命令 Command
    - Memento
    - Interpreter
    - Chain of Responsibility
3. 结构型：可以让你把类或对象组合到更大的结构中。
    - 装饰者 Decorator
    - 组合 Composite
    - 适配器 Adapter
    - 代理 Proxy
    - 外观 Facade
    - Flyweight
    - Bridge

模式所处理的是类或对象

1. 类模式：描述类之间的关系如何通过继承定义。类模式的关系是在编译时建立的。
2. 对象模式：描述对象之间的关系，而且主要是利用组合定义。对象模式的关系通常在运行时建立，而且更动态、更有弹性。

反模式

定义：告诉你如何采用一个不好的解决方法解决一个问题，从而避免使用该解决方案。

其他模式

- 桥接 Bridge Pattern：不只改变你的实现，也改变你的抽象。
- 生成器模式 Builder Pattern：
- 责任链
- 蝇量 Flyweight：让某个类的一个实例能用来提供许多“虚拟实例”。
- 解释器模式 Interpreter
- 中介者 Mediator
- 原型 Prototype

## 值得看的资料

书

Design Patterns: Elements of Reusable Object-Oriented Software

The timeless way of building

a Pattern language

网站

[the portland patterns repository](http://c2.com/cgi/wiki?WelcomeVisitors)

[the hillside group](http://hillside.net)

会议和研讨会

OOPSLA




## 参考资料

《Head First 设计模式》