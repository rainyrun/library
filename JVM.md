# JVM

编译jdk的实验

1. 获取openJDK源码：http://hg.openjdk.java.net/jdk7u/jdk7u (git上有吗？)或，下载打包好的源码：http://jdk7.java.net/source.html
2. 阅读 README-builds.html 文档

## Java内存区域

运行时数据区

- 方法区 Method Area
- 虚拟机栈 VM Stack
- 本地方法栈 Native Method Stack
- 堆 Heap
- 程序计数器 Program Counter Register

程序计数器

可以看作是当前线程所执行的字节码的行号指示器。每条线程有一个独立的程序计数器。

如果线程执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，则计数器值为空。

Java 虚拟机栈

是线程私有的，生命周期与线程相同。每个Java方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完毕的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈到过程。

局部变量表存放了编译期可知的各种基本数据类型、对象引用、returnAddress类型(指向了一条字节码指令的地址)。当进入一个方法时，这个方法需要在桢中分配多大的局部变量空间是完全确定的，不会在方法执行期间改变。

本地方法栈

为虚拟机使用到的 Native 方法服务。

Java 堆

被所有线程共享的一块内存区域，用来存放对象实例，是垃圾收集器管理的主要区域。

Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。

方法区

是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

运行时常量池(Runtime Constant Pool)是方法区的一部分。常量池用于存放编译期生成的各种字面量和符号引用。

直接内存

### hotspot 虚拟机对象

对象的创建

1. 加载类
2. 为对象分配内存，有2种方式
    1. 同步式的内存分配
    2. 预先给线程分配一小块内存（本地线程分配缓冲TLAB）
3. 初始化分配的内存空间
4. 对对象进行设置
5. 执行init方法，初始化对象

对象的内存布局

1. 对象头 Header，分为2部分内容
    1. 存储对象自身的运行时数据，如：HashCode、GC分代年龄、锁状态标志等
    2. 类型指针，指向对象的类元数据的指针。
    3. 数组长度，仅当对象是数组时存储。
2. 实例数据 Instance Data，对象真正存储的有效信息。
2. 对齐填充 Padding，起占位符的作用。

对象的访问定位

Java 程序需要通过栈上的reference数据来操作堆上的具体对象。

1. 使用句柄访问
    1. Java 堆中会分配一块内存作为句柄池
    2. reference 中存储对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。

![通过句柄访问对象](images/JVM/通过句柄访问对象.png)

2. 直接指针访问

![直接指针访问对象](images/JVM/直接指针访问对象.png)

## 垃圾回收和内存分配

核心的3个问题

- 哪些内存需要回收？
- 什么时候回收？
- 怎么回收？

垃圾回收主要关注堆内存的回收。

### 对象是否死去

垃圾回收前，要判断堆内哪些对象已“死去”（即不可能再被使用的对象）。判断方式

1. 引用计数算法（不是主流虚拟机使用的算法）
    1. 实现原理
        1. 给对象添加一个引用计数器
        2. 对象被引用时，计数器+1
        3. 取消引用时，计数器-1
        4. 当计数器为0时，对象“死去”
    2. 存在问题：对象间循环引用时，2个对象都永远不会“死去”
2. 可达性分析算法（主流算法）
    1. 实现原理
        1. 以 "GC Roots" 对象作为起点，向下搜索。Java 中，可作为GC Roots的对象有
            1. 虚拟机栈中引用的对象
            2. 方法区中静态属性引用的对象
            3. 方法区中常量引用的对象
            4. 本地方法栈中JNI(即 Native方法)引用的对象
        2. 能够到达的对象是“活的”，不能到达的对象是“死的”。

引用的含义

传统引用的含义：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。

当内存空间在垃圾收集后还是非常紧张，希望可以抛弃某些对象，腾出内存空间。这时候引用的含义需要被扩充。

1. 强引用：类似 `Object obj = new Object()` 这类引用。对象有强引用，则永远不会被垃圾收集器回收。
2. 软引用：描述有用但非必需的对象。当内存不够时，可以被回收。(SoftReference)
3. 弱引用：描述非必需的对象，比软引用强度更弱。有弱引用的对象只能生存到下一次垃圾回收前。(WeakReference)
4. 虚引用：是最弱的引用关系。对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象的实例。仅能在这个对象被垃圾收集器回收时收到一个系统通知。(PhantomReference)

对象如何真正死去？

对象宣告死亡，至少需要经过两次标记过程

1. 经可达性分析后，发现没有与 GC Roots 相连，会被第一次标记并进行筛选
    1. 当对象没有覆盖 finalize() 方法，或者 finalize() 方法已被虚拟机调用。则不执行 finalize() 方法。
    2. 否则，将对象放在 F-Queue 队列中，等待执行 finalize() 方法。
2. GC 对 F-Queue 队列中的对象进行第二次小规模的标记
    1. 在 finalize() 方法执行时，对象有引用，则不会被回收。
    2. 否则，被回收

回收方法区

主要回收两部分内容

1. 废弃常量。判断标准
    1. 字符串没有被任何String对象引用。
2. 无用的类
    1. 该类的所有实例都已被回收。
    2. 加载该类的ClassLoader已被回收
    3. 该类对应的Class对象没有被引用，即无法通过反射访问该类的方法。

### 垃圾收集算法

标记-清除算法

最基础的算法，其他算法都是在该算法的基础上改进的。

- 原理
- 不足
    1. 效率低
    2. 垃圾清除后会产生大量不连续的内存碎片

复制算法

为解决效率问题。

- 原理
    1. 将可用内存等分成2块。
    2. 使用其中一块A直到该块的内存消耗完
    3. 将存活对象复制到空闲的另一块B，并将A块的内存清理掉。
    4. 使用B块重复步骤2-4
- 不足
    1. 只能使用一半内存，浪费（可以修改分配内存的比例）

标记-整理算法

针对老年代（对象存活率高）

- 原理
    1. 标记
    2. 将可回收对象移动到内存的一端，然后清理掉端边界以外的内存。

分代收集算法

根据对象存活周期的不同将内存划分为几块。一般把Java堆分为新生代和老年代，使用不同的垃圾清理算法。

### 垃圾收集器

内存回收的具体实现。

Serial 收集器

是一个单线程的收集器，运行时会停掉其他线程。

ParNew 收集器

Serial 收集器的多线程版本。可以与CMS收集器配和使用

CMS 收集器

Concurrent Mark Sweep，








