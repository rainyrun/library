# 数据结构

### 复杂度度量

![时间复杂度记号](images/DSA/时间复杂度记号.png)

# 算法


思考

已知的算法就那么多，常用的也没有很多，给每个算法明确一个功能，使用的时候，找到这个适用的算法是不是就行？比如，有序查找，就看二分查找是不是适用。

查找找查找的算法，排序找排序的算法

查找

顺序查找
二分查找
哈希表查找
二叉排序树查找

排序

插入排序
冒泡排序
归并排序
快速排序


回溯算法适合用递归实现，也是用拆分的思路。

可以用动态规划求解的问题的特点

1. 求问题的最优解
2. 问题可以拆分成子问题，子问题的最优解，合起来就是问题的最优解
3. 子问题间，有相互重叠的更小的子问题
4. 从上往下分析，从下往上求解

递归就是拆一个，剩下n-1，n-1的解法和n相同

动态规划是拆i个，剩下n-i个，且解法和n个时相同

可以使用递归的情况

1. 结构是嵌套的，有重复性的
2. 拆除一个，剩下的可以用同样的方法解决

选择剩余字符的方法：将已处理的字符放在末尾，即将字符数组分成两部分，已处理和未处理部分。

# 数据结构与算法分析——Java语言描述

## 表、栈和队列

### 抽象数据类型

抽象数据类型(abstract data type，ADT)是带有一组操作的一些对象的集合。

LinkedList

modCount代表自从构造以来对链表所做改变的次数。每次对add或remove的调用都将更新modCount。当一个迭代器被建立时，他将存储集合的modCount。每次对一个迭代器方法（next或remove）调用都将用该链表内的当前modCount检测在迭代器内存储的modCount，当这两个计数不匹配时，抛出ConcurrentModificationException异常。

栈

在实际计算机中的栈，常常是从内存分区的高端向下增长。

Set

Set接口代表不允许有重复元的Collection。


# 数据结构

## 复杂度分析

大 O 复杂度表示法

是渐进时间复杂度，表示代码执行时间随数据规模增长的变化趋势。

```
T(n) = O(f(n))
```

n: 代码的规模
T(n): 总的执行时间
f(n): 每行代码执行的次数总和

### 时间复杂度分析

1. 只关注循环执行次数最多的代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

时间复杂度举例

```java
void test(int n) {
    int i = 1;
    while (i <= n) {
        i = i * 2;
    }
}
// O(logn)
```

分析：第三、四行决定了总的执行次数，设执行次数为x，则需满足 i = 2^x <= n，即 x = logn

```java
int cal (int m, int n) {
    int sum1 = 0;
    int i = 1;
    for (; i < m; i++>) {
        sum1 += i;
    }

    int sum2 = 0;
    int j = 1;
    for (; j < n; j++>) {
        sum2 += j;
    }
    return sum1 + sum2;
}
// O(m + n)
```

分析：因为无法评估 m 和 n 谁量级大，所以都不能忽略

最好、最坏情况时间复杂度

代码在最理想、最糟糕情况下的时间复杂度

平均情况时间复杂度

加权平均时间复杂度 或 期望时间复杂度

sum(每种情况下的代码执行次数 * 这种情况发生的概率)

均摊时间复杂度

假如：每一次O(n)的操作，都会跟着n-1次O(1)的操作。

那么：把耗时多的那次操作摊到接下来的n-1次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)

### 空间复杂度分析

渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。

## 数组

Array 是一个线性表数据结构。用一组连续的空间，来存储一组具有相同类型的数据。

线性表：数据排成一条线。如数组、链表、队列、栈。

非线性表：数据不是简单的前后结构。如树、图。

插入：如果不需要考虑数据顺序，可以将要插入位置的数据放到数组末尾。此时插入的时间复杂度为O(1)

删除：如果不需要考虑数据顺序，可以先标记需要删除的位置，等到数组没有空间可以存放数据时，一次性删除数据。

## 链表

在缓存有限的情况下，当缓存不够用时，清理策略有以下几种

- 先进先出FIFO策略 First in, First Out
- 最少使用策略 LFU Least Frequently Used
- 最近最少使用策略 LRU Least Recently Used

单链表、循环链表、双向链表、双向循环链表

技巧：使用哨兵，如头结点；留意边界条件，如链表为空、链表只有1个结点、处理头尾结点；画图辅助

练习：单链表反转、链表中环的检测、2个有序链表合并、删除链表倒数第n个结点、求链表的中间结点

## 栈

是一个操作受限的线性表数据结构

虽然数组和链表可以代替栈的功能，但是，栈减少了对外开放的接口，增加了限制，使用起来更简单不容易出错。

顺序栈：用数组实现的栈

链式栈：用链表实现的栈

任务：自己写个栈，然后用栈计算四则表达式。用栈模拟浏览器的前进后退

## 队列

操作：入队、出队

是一个操作受限的线性表数据结构

顺序队列、链式队列

任务：实现队列（数组、链表、循环、阻塞、线程并发安全的队列）、无锁并发队列

## 递归

去的过程叫递，回来的过程叫归。

使用递归需要满足的3个条件

1. 一个问题的解可以分解为几个子问题的解
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3. 存在递归终止条件

写递归代码的关键：递推公式、递归基（递归终止条件）

示例：有n个台阶，可以一次走1阶，也可以一次走2阶，一共有多个走法

```java
int f(int n) {
    // 递归终止条件
    if (n == 1) return 1;
    if (n == 2) return 2;
    // 递归公式
    return f(n - 1) + f(n - 2);
}
```

递归代码导致的问题

1. 堆栈溢出：递归深度太深，每一层函数又需要栈帧保存临时变量，当栈空间不够时，造成 StackOverflow
2. 重复计算：如上面的示例，会重复计算f(n-2)。解决办法：将计算结果保持在散列表中，散列表中没有结果再计算。
3. 空间复杂度高：示例的空间复杂度为O(n)

递归代码改成非递归

示例改成非递归

```java
int f(n) {
    int ret = 0;
    int pre = 2;
    int prepre = 1;
    for (int i = 3; i <= n; i++) {
        ret = pre + prepre;
        prepre = pre;
        pre = ret;
    }
    return ret;
}
```

## 排序

任务：实现各类排序，归并排序使用哨兵简化编程

任务：字符串中有大小写字符和数字，要求按照小写字符、大写字符、数字实现排序。原地排序，O(n)复杂度。

思路：参考快速排序里找轴点位置的方法，从头开始遍历，记录小写字符的尾部，大写字符的尾部，数字的开头。遇到小写字符，和小写字符的尾部交换；遇到大写字符增加大写字符的尾部；遇到数字，和数字的开头交换。当大写字符的尾部=数字的开头时，遍历结束。

任务：看 java 默认的排序算法

思路都是升序的排序方式。

分析排序算法

1. 执行效率：最好最坏平均复杂度
2. 内存消耗：空间复杂度
3. 稳定性：值相等的元素，排序前后的相对位置不变，则是稳定的。使用场景：有2个排序条件A和B，使用稳定排序，可以保证按照B排序后，再按A排序，能得到按A排序，且A相同时按B排序的结果。

| 算法 | 最好时间复杂度 | 最坏时间复杂度 | 平均时间复杂度 | 空间复杂度 | 稳定性 |
| --- | --- | --- | --- | --- | --- |
| 冒泡 | O(n) | O(n^2) | O(n^2) | O(1) | 稳定 |
| 插入 | O(n) | O(n^2) | O(n^2) | O(1) | 稳定 |
| 选择 | O(n^2) | O(n^2) | O(n^2) | O(1) | 不稳定 |
| 归并 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 稳定 |
| 快速 | O(nlogn) | O(n^2) | O(nlogn) | O(1) | 不稳定 |
| 计数 |  |  | O(n + k) | O(k) | 稳定 |
| 桶 |  |  | O(n) | O(n) | 稳定 |
| 基数 |  |  | O(n * k) | O(n) | 稳定 |

### 冒泡排序

实现思路：从前往后依次对比相邻的2个数，将大的放到后面，最终最大的排在最后。然后重复这个过程，直到全部有序，即没有发生交换。一次排序至少会有一个数放在它应该在的位置。

平均时间复杂度

可以用有序度来计算。数组是升序的，则是满有序度，任意2个数字都是升序的，即有 n(n -1)/2 个有序对。数组是降序的，则有序度为0，即任意2个数字都是逆序的。粗略估计平均需要 n(n -1)/4 次交换，所以平均复杂度是 O(n2)。

### 插入排序

实现思路：位置 i 之前都是有序的，将 i + 1 位置的数字插入到前i+1的合适位置，直到n。

移动次数等于逆序度。

### 选择排序

实现思路：位置 i 之前都是有序的，从 i + 1 到 n 选择一个最小的数，放在 i + 1 的位置。重复，直到有序。

### 归并排序

实现思路：采用递归的思路。有2个有序的数组，将2个数组合并成一个有序的数组。递归终止条件是数组仅有一个数。

适合大规模数据排序。

时间复杂度递推公式： T(n) = 2 * T(n / 2) + n;

空间复杂度：虽然每轮排序都会申请一个O(n)的空间，共有logn轮。但是每轮排序后，空间都被释放了，不是累加的，因此最终的空间复杂度是O(n)

任务：有10个300MB的日志文件，每个文件都按照时间顺序排序。希望将它们合成一个按时间排序的文件，但是内存只有1GB。

思路：多路归并排序（外排序）

### 快速排序

实现思路：递归的思路。选一个数作为轴点，取出这个数留出一个空位，所有大于这个数的放在空位右侧，小于这个数的放在左侧，最终空位就是这个数排序后的位置。然后将轴点2侧的数组按照这个思路排序。递归终止条件：数组只剩一个数。

当选中的轴点，刚好处在排序后的数据中间的位置时，快速排序的复杂度最低为O(nlogn)；轴点选在端点，则复杂度退化为O(n^2)。

轴点的选取方法：

- 三数取中法：从区间的首、尾、中间各取一个数，选择中间的数值作为轴点。
- 随机法：随机选一个轴点。

任务：用 O(n) 复杂度找到数组中第K大的元素。

思路：取 a[n - 1] 作为轴点，得到位置p，和K比较。大于K，则在a[0...p]找第K大元素；小于K，则在a[p+2...n-1]；p + 1 == K，则当前即为所求。

时间复杂度 T(n) = n + n/2 + n/4 + ... + 1 = n (1 + 1/2 + 1/4 + ... + 1/(2^logn)) = n(1-1/n)/(1-1/2) = 2n - 1; 时间复杂度为 O(n)

### 桶排序

思路：将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的。

场景：外排序，数据量比较大，但是内存有限。

### 计数排序

思路：桶排序的特殊情况。排序的n个数据范围不大，如最大值是k，最小值是1。则可以把数据分成k个桶，每个桶的数据都是一样的，省掉了桶内排序的时间。

### 基数排序

思路：借助稳定的桶排序算法，将低位进行排序，以此类推直到最高位完成排序，此时数据是有序的。假设有k位数，则时间复杂度是 O(k * n)。比如手机号码的排序

## 二分查找

前置条件：数据有序

思路：每次都和中间的元素对比，将待查找区间缩短为之前的一半。时间复杂度为O(logn)

任务：写一个二分查找及其变形

二分查找的变形问题

- 查找第一个值等于给定值的元素
- 查找最后一个值等于给定值的元素
- 查找第一个大于等于给定值的元素
- 查找最后一个小于等于给定值的元素

## 跳表

用链表实现，可以支持类似二分查找的算法，时间复杂度 O(logn)

对链表建索引，可以减少查找的节点数

```
第二级索引   1       5       9
            |      |       |
第一级索引   1   3   5   7   9
            |   |   |   |   |
原始链表     1 2 3 4 5 6 7 8 9 10
```

时间复杂度

如果每隔一个节点建一级索引，最顶层的索引有2个结点。假设一共有h级索引，那么 2^(h + 1) = n; h = logn - 1。而找到数据所在区间后，每一级索引最多只需要遍历3个结点，就能到下一级索引。所以时间复杂度是 O(3logn) = O(logn)

空间复杂度

需要占用的空间 = n/2 + n/4 + .... + 2 = n(1/2 + 1/4 + ... + 1/2^(logn - 1))=n(1/2-(1/2)^logn)/(1-1/2) = 2n(1/2-1/n) = n - 2 = O(n)

支持动态插入、删除操作。是一种动态数据结构

如何维持索引节点和链表的平衡？即如何保证2个索引节点间的链表不过分长？

答：通过随机函数，决定将某个节点插入到哪几级索引中。

任务：实现跳表，和它的查询、插入、删除操作

## 散列表

散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实是数组的一种扩展，由数组演化而来。

通过散列函数把元素的键值（唯一标识了该元素）映射为下标，然后将数据存储在数组中对应下标的位置。

散列函数设计的基本要求

0. 散列值是一个非负整数
1. 如果 key1 == key2，那么 hash(key1) == hash(key2)
2. 如果 key1 != key2，当 hash(key1) == hash(key2) 时，需要解决散列冲突问题

散列冲突的解决方法

- 开放寻址法 (open addressing): 如果出现冲突，就重新探测一个空闲位置。
    - 线性探测 (linear probing): 从当前位置开始，往后依次查找，看是否有空闲位置。
    - 二次探测 (quadratic probing): 探测步长为原来的二次方，即 hash(key) + 1, hash(key) + 2, hash(key) + 4, ...
    - 双重散列(double hashing): 使用一组散列函数 hash1(key), hash2(key), ...当hash(key)探测的位置被占用时，使用 hash1(key) 重新探测位置，以此类推。
- 链表法 (chaining): 散列表的槽位是一个链表，冲突的元素依次插入链表。查找、删除时，找到槽位后，遍历链表即可。

插入数据越多，空闲位置越少，发生冲突可能性越大。因此需要保证一定比例的空闲槽位，用装载因子(=表中元素/散列表长度)标识。

开放寻址法

- 优点
    - 数据存储在数组，可以利用CPU缓存加快查找速度
    - 没有指针，序列化起来比较简单
- 缺点
    - 删除操作需要使用标记删除法，不能直接置空。
    - 更容易产生冲突，因此装载因子不能太大，因此更浪费内存空间
- 总结：适合数据量小，装载因子小

链表法

- 优点
    - 内存利用率高，链表节点可以需要的时候再创建
    - 装载因子可以大于1
- 缺点
    - 链表要存储指针，存储小对象时，比较消耗内存。
    - 使用的内存不连续，对CPU缓存不友好。
- 改进点：可以使用跳表、红黑树代替链表。这样冲突时的查找效率是 O(logn)
- 总结：适合大对象、大数据量


散列表碰撞攻击：通过精心构造的数据，使所有的数据都散列到同一个槽内，使得查询效率退化为O(n)。当查询一个数据时会消耗大量CPU或线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击。

工业级散列表

- 特点
    - 支持快速的增删查
    - 内存占用合理
    - 性能稳定，极端情况也不会退化到难以接受的程度
- 散列函数的设计
    - 不能太复杂，导致消耗过多计算资源。
    - 应尽可能随机并均匀分布
- 动态扩容，保证一定的装载因子。缺点：扩容时，数据需要重新散列到新的表里，此时的插入操作时间会很长。解决方案：将扩容操作穿插在插入操作中。
    - 需要扩容时，先申请空间，然后将要插入的数据散列到新表里。每次插入操作，都将老表中的部分数据散列到新表里。多次插入后，就会将老表搬空。
    - 查询时，先从新表查，查不到再到老表查。
- 选择合适的散列冲突解决办法
- 动态缩容。当对空间消耗比较敏感时。

HashMap

- 初始大小 16
- 装载因子 0.75，支持动态扩容，扩容为原来的2倍
- 用链表法解决散列冲突。当链表长度 > 8，使用红黑树代替链表。树节点个数 < 8，恢复成链表，因为红黑树需要维持平衡。
- 散列函数：(h ^ (h >>> 16)) & (capacity - 1); h = hashCode()

LinkedHashMap

插入、查找、删除都是 O(1)

作用：链表和散列表结合，用双向链表记录节点插入的顺序，新插入的在尾部。同时链表节点散列到散列表中，能够用O(1)的复杂度实现查找。

插入：先查找是否存在，存在则删除，并将节点添加到双向链表的尾部

查找：将找到的节点放到尾部

删除：将找到的节点删除

节点的数据结构

```
| prev | data | next | hnext |
```

prev 和 next 是双向链表中的前驱和后继；hnext 是散列表中的拉链的后继。

## 哈希算法

定义：将任意长度的二进制值串映射为固定长度的二进制值串，这个映射规则就是哈希算法。映射后的二进制值串就是哈希值。

哈希算法需要满足的条件

- 不能反向推导出原始数据
- 对输入敏感，原始数据有一个二进制位发生变化，最后得到的哈希值也大不相同。
- 对于不同的原始数据，哈希值相同的概率非常小。
- 执行效率高

哈希值越长的哈希算法，散列冲突的概率越低（鸽巢原理）

应用场景

- 安全加密。常见加密算法：MD5, SHA, DES, AES
- 唯一标识。取文件的一部分作为信息摘要，存放在散列表中，用来在大量文件中查找某个大文件是否存在。
- 数据校验。取文件的一部分作为信息摘要，存储在某个地方，再次获取该文件后，计算文件摘要，和存储的摘要对比，看文件是否被修改。
- 散列函数。
- 负载均衡。会话粘滞(session sticky): 同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。解决方案：对客户端IP或sessionId计算哈希值，将哈希值与服务器列表的大小取模运算，得到应该被路由到的服务器编号。
- 数据分片。计算大量日志里用户的关键词出现的次数：使用n台机器处理，依次遍历日志里的关键词，取哈希值，和n取模得到机器编号，最后这台机器上就能计算出该关键词出现的次数。
- 分布式存储。一致性哈希算法。

一致性哈希算法。

目标：当处理的机器扩容时，老哈希值能映射到老的机器上，不至于重新计算一遍分配的机器。

原理：假设有k个机器，哈希值范围是[0, MAX]。k个机器分布在一个单位圆上，当元素的哈希值对360（也可以是任意值m，且 m >> k）取余后，顺时针放到最近的一个机器上。每个机器负责 m / k 个小区间内哈希到的元素。当有新机器加入时，就将它后面的机器里的元素重新映射一遍。当一个机器被删除时，就把它上面的数据搬到它后面的机器。

## 树，二叉树

树

高度：节点到叶子节点的最长路径（边数）（从下往上数）

深度：根节点到这个节点的边数（从上往下数）

层数：节点的深度 + 1

树的高度：根节点的高度

### 二叉树

定义：每个节点最多有2个子节点。满二叉树：除了叶子节点外，每个节点都有2个子节点的数。完全二叉树：除最后一层外，其他层的节点数都是满的，且最后一层的叶子节点都靠左排列。

二叉树的表示方法

链式存储法

```
                | left | data1 | right |
                -----------------------
| left | data2 | right |            | left | data3 | right |
-----------------------              -----------------------
```

顺序存储法

节点X存储在下标为i的位置，则它的左节点在 2i，右节点在 2i + 1。

```
| 空 | data1 | data2 | data3 | data2 的左节点 | data2 的右节点 | data3 的左节点 | data3 的右节点 | ……
```

二叉树的遍历

前序遍历：先打印节点，再打印左子树，再打印右子树

中序遍历：先打印左子树，再打印节点，再打印右子树

后序遍历：先打印左子树，再打印右子树，再打印节点

层序遍历：从第一层开始，依次打印每层，每层从左到右遍历

任务：完成树的3种遍历

因为每个节点最多会被访问2遍，所以时间复杂度是O(n)

问：给n个节点，一共有几种二叉树？答：f(n) = f(0) * f(n - 1) + f(1) * f(n - 2) + f(2) * f(n -3) + ...... + f(n - 1) * f(0)

### 二叉查找树 Binary Search Tree

目标：支持动态数据集的快速插入、删除、查找。

定义：树中的每个节点，左子树节点的值都小于该节点，右子树节点的值都大于这个节点的值。（rainy：重复数据怎么办？搞个链表？）

插入：如果插入的节点A比根节点大，且根的右节点为空，则将A插入到右节点，否则继续合右节点对比；如果A比根节点小，且根没有左节点，则A插入到左节点，否则和左子树对比。

删除：找到要删除的节点A，如果A没有子树，则直接删除；A如果只有一个子树B，将子树的根节点B替代A的位置；如果都有，则在右子树中找到最左的节点C，节点C的值在左子树中是最小的，因此它一定没有左节点，删除D（用和删除A同样的方法）并用D代替A的位置。

查找：类似二分查找。要找的值A大于根节点，则在右子树查找；小于根节点，则在左子树查找。

其他查找操作：查找最大节点、最小节点、前驱节点、后继节点

任务：实现二叉查找树，深度优先遍历求树高。

有重复数据的处理办法

1. 搞个数据或链表，放在树节点上
2. 右子树存放大于等于的数据。查找、删除操作需要持续进行直到遇到子节点，这样可以找到或删除所有相同数据。

完全二叉查找树的时间复杂度 O(h) = O(logn) h 是树高，n是节点数。

最坏的时间复杂度是当树变成了线性，是O(n)

问：为什么不用散列表代替？散列表可以做到 O(1) 的插入、查找、删除。答：二叉树中数据是有序存储的；散列表扩容耗时，散列冲突时性能不稳定；散列表设计比较复杂；散列表有装载因子，会浪费一定空间。


### 平衡二叉查找树

目标：为了保持logn的树高，保持稳定的增删查复杂度。

定义：二叉树中任意一个节点的左右子树的高度相差不能大于1。

其他平衡二叉查找树：AVL树、伸展树、树堆。

#### 红黑树

红黑树是一种平衡二叉查找树。红黑树并没有完全遵循平衡二叉查找树的定义。但它满足树高是 logn 数量级的。

定义和要求：

- 根节点是黑色的
- 每个叶子节点都是黑色的空节点（NULL）（这个设定是为了简化代码）
- 任何相邻的节点都不能同时为红色，即红色节点是被黑色节点隔开的。
- 每个节点，从该节点到达其他可达叶子节点的所有路径，都包含相同的黑色节点。

时间复杂度分析

将红色节点取出，红色节点的子树会以祖父节点为父节点，二叉树会变成四叉树，且叶子节点都在同一层。此时树高不超过logn。因为红色节点不能相邻，将红色节点加上后，树高不超过2logn。因此时间复杂度是 O(logn)

插入：插入的节点A是红色的。二叉查找树新插入的节点总在叶子节点上。

插入后的红黑颜色调整：

1. 当A的父节点B是黑色，则无需处理；
2. 当A是根节点，则直接变黑；
3. 如果A的父节点B是红色的
    3.1 父节点B的兄弟节点C也是红色的，那直接将他俩变成黑色的，它俩的父节点D变成红色的。将D按照本规则进行红黑调整；
    3.2 父节点B的兄弟节点D是黑色的
        3.2.1 如果A是B的右子树，则将B逆时针旋转(zag, 左旋)，将B变成A的左子树，并将B按3.2.2情况调整；
        3.2.2 如果A是B的左子树，则将祖父节点D顺时针旋转(zig, 右旋)，将B变为子树的根节点，然后将B变为黑色，D变为红色。此时红黑树恢复平衡。

删除前的调整

1. 被删除的节点A是黑色的
    1.1 A只有一个子节点B
        1.1.1 子节点B是红色的，则将A删除，用B代替A，同时将B染黑。此时红黑树恢复平衡。
    1.2 


#### AVL树

严格平衡的二叉树，满足平衡二叉查找树的定义。任何一棵二叉查找树都可以在O(logn)时间内转换成一棵平衡二叉查找树。

![二叉平衡树的旋转](images/DSA/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC.png)

插入：按照二叉平衡树的插入方式，插入节点A。调整树高：从A的父节点向上遍历，直到发现节点B失衡。如果B是其父节点C的右子树，且C也是其父节点D的右子树，则通过逆时针单旋(zag)D来重新达到平衡；如果B是C的左子树，且C是D的右子树，则先通过顺时针单旋(zig)C，再zag D来重新达到平衡。剩下2种对称情况是相同的处理方式。

删除：按照二叉平衡树的删除方式，删除A。从其父节点往上遍历，调整失衡节点的树高。与插入不同，插入调整的子树一定是其父节点的子树中较高的那个，调整1次后整棵树即可恢复平衡。而删除后失衡的子树可能是其父节点的子树中较低的一个，调整后因为树高-1，父节点可能失衡，需要继续向上调整树高。

#### 伸展树

使用场景：

- 刚刚被访问的节点，极有可能在不久后再次被访问
- 即将要访问的节点，极有可能在刚被访问的节点附近

方案一，单层伸展：将刚被访问的节点A，从父节点开始逐层单旋，直到将A转移到树根。

缺点：在树是线性的时候，单次调整的效率为 O(n)；所有节点查找一遍后，树会恢复原样。

方案二，双层伸展：先选择刚被访问的节点A的祖父节点C，将父节点B转至子树树根，再将A旋转至子树树根。重复这个步骤直到A成为树根。

效率：单次操作均可在分摊的O(logn)时间内完成

#### 多路搜索树 B树

m阶B树，即有m个分支的平衡搜索树

## 递归树

用来分析递归算法的时间复杂度

如，归并排序的递归树每层的时间消耗是n，共有logn层，因此时间复杂度是O(nlogn)

如，快速排序的平均时间复杂度，假如每次选择的轴点，都将数据分成了1:9的区间，则快排的递归树中，从跟节点到叶节点，最短的路径满足 1 = n/(10^h)，最长路径满足 1 = n*9^h/(10^h)。即 log(10)n < h < log(10/9)n (括号内是底数)。因为快排每层都会遍历一遍数据，所以每层消耗的时间是n，如第三层的时间消耗 = n/10^2 + 9n/10^2 + 9n/10^2 + n9^2/10^2 = n

快排的递归树

```
q(n)

q(n/10)    q(9n/10)

q(n/10^2)  q(9n/10^2)  q(9n/10^2) q(n*9^2/10^2)
```

如，斐波那契数列。递归公式是 f(n) = f(n - 1) + f(n - 2)。递归树每层的消耗是相加操作的次数，即每层的时间消耗是 0,1,2,4...。因为每层数据规模会-1或者-2，所以层数 n/2 < h < n。如果路径长都为n，则消耗时间为 1 + 2 + ... + 2^(n-1) = 2^n - 1；如果路径长都为 n/2 则消耗时间为 2^(n/2) - 1。所以时间复杂度在 O(2^(n/2)) < T(n) < O(2^n)

如，全排列问题的递归解法。 T(n) = nT(n - 1) + n

第一层有n次交换，第二层有n个节点，每个节点有n-1次交换

```
分解：     f(n) -> n个f(n-1) -> n(n-1)个f(n-2) -> n(n-1)(n-2)...1个1

时间成本：  n+      n(n-1)+      n(n-1)(n-2)+...     n!             
```

所以 O(n!) < T(n) < O(n*n!)

## 堆

目的：在O(logn)的时间内选出数据中最大（或最小）的那个。

堆是一个完全二叉树。堆中的每一个节点的值都必须大于等于其子树中的每个节点的值（大根堆）。

堆用数组来存储。

插入：将数据放入叶子节点，再将数据”堆化“(heapify)（向上）：顺着节点所在的路径，向上对比父节点，比父节点大，则交换位置；否则堆化完成。

删除：删除堆顶节点，将末尾的叶子节点放在堆顶，然后堆化（向下）：向下和子节点对比，并和最大的交换位置，直到自己最大。

构建堆：

- 假设堆中只有1个数据，然后将剩下的数据插入堆中。
- 从第一个非叶子的节点开始，向下堆化。

构建堆复杂度位O(n): 向下堆化过程中，节点比较的次数和该节点的高度有关。比较次数= 2^0 * h + 2 * (h-1) + 2^2 * (h-2) + ... + 2^(h-1) * 1 = S1; S2 = 2 * S1; S2 - S1 = -h + 2 + 2^2 + ... + 2^h = -h + 2^(h+1) -2=2n-logn-2 

堆排序：先将数据堆化。将根节点和最后一个叶节点交换位置，将剩下的n-1个数据进行堆化，不断重复这个操作，就组成了有序队列。O(nlogn)，不稳定。

快速排序 vs 堆排序

堆排序访问节点顺序是跳着访问的，比如从根节点向下堆化，访问的数组位置是1,2,4,8，对cpu缓存不友好。堆排序数据交换的次数比快速排序多（通过逆序度对比）。

任务：实现一个堆

### 堆的应用

优先级队列：用堆实现。场景：多路归并排序时，判断每组第一个数据组成的数组中最小的那个，就可以用堆。

求TopK

静态数据集合：维护一个大小为K的小根堆，从数组中依次取出数据，比堆顶大，则删除堆顶，并将该数据插入堆。O(nlogk)

动态数据集合：插入数据时，就将数据和小根堆的根对比。即一直维护一个K大小的小根堆。

求中位数

先将数据从大到小排序，将前一半放到小根堆里，将后一半放在大根堆里。大根堆的根就是中位数。插入数据时，如果数据比大根堆的根小，则插入大根堆；如果比小根堆的根大，则插入小根堆。插入完成后，如果大小根堆的数量不满足一半一半的要求，则调整堆的大小，将数据从一个堆删除，插入到另一个堆里。

## 图

图由点(vertex)和边(edge)构成。边有方向的图是有向图。边没有方向的图是无向图。边上有权重，则是带权图(weighted graph)。

度(degree): 和顶点相连的边数

### 图的存储

邻接矩阵 Adjacency Matrix

用一个二维数组A存储，下标表示顶点，数组存储1表示2个顶点有边连接，存储0表示无边。如，对于有向图 `A[i][j]` 的值为1，表示顶点 i 和 j 之间有从 i 指向 j 的边；对于无向图，`A[j][i]` 的值也为1；对于加权图，表示 i 和 j 之间有边，且权重为1。

缺点：对于边少的稀疏图(Sparse Matrix)，浪费空间

优点：存储简单；可以转化为矩阵的运算。

邻接表 Adjacency List

用一个数组存储顶点，用链表存储这个顶点指向的其他顶点。也可以将链表换成二叉查找树等其他更高效的数据结构。

逆邻接表：用一个数组存储顶点，用链表存储指向这个顶点的其他顶点。

当内存不足时，可以考虑将数据持久化到数据库里。如建一个数据库表，数据库表的第一列表示顶点，第二列存储该顶点指向的其他顶点。所以当一个顶点指向n个顶点时，它会在数据库里存储n行记录。这样，数据库里存储了所有的边。然后给2列都建索引，求这个节点指向了谁，查第一列，求谁指向了这个节点，查第二列。

### 深度和广度优先搜索

广度优先搜索（BFS） Breadth First Search

从起始顶点开始，一层一层的遍历。

实现原理：使用visited数组记录顶点是否被访问过。将起始顶点入队queue，然后出队，并依次取出它的子节点入队；然后子节点出队，判断子节点是否访问过，没有访问过则并依次取出它的子节点再入队，直到所有节点都被访问完毕。

任务：求：s到t的最短路径。答：在BFS时，维护一个顶点数组，该数组记录了某顶点的上一层顶点是谁。当找到t时，从t一路查找上一层顶点直到s，就获得了s到t的最短路径。

时间复杂度：最坏 O(V + E) 因为连通图中 E >= V - 1，所以复杂度可以简化成 O(E)

空间复杂度：O(V) 使用的 queue，visited，prev 数组的大小都为 V

深度优先优先搜索（DFS） Depth First Search

从起始顶点开始，选择一条边一直往下走，直到走到头，再返回上一个顶点，选另一条往下走。直到走完全部顶点。

实现原理：使用回溯算法。记录访问的顶点路径，当顶点所有相邻顶点都被访问过后，返回上一个顶点继续向下访问。直到访问完所有的顶点。

任务：求：s到t的所有路径。答：每当访问到t时，就把访问路径打印出来。

时间复杂度：O(E)

空间复杂度：O(V)

## 字符串匹配

主串：在主串中查找。长度为n

模式串：想要在主串中查找到的串。长度m

BF算法 Brute Force

思路: 从主串的第一个字符开始，和模式串的字符依次比较，如果都一一匹配，则找到了模式串；如果某个字符不匹配，则从主串的第二个字符开始，和模式串的字符依次比较。直到比较到最后一个需要和模式串比对的子串为止。

最坏时间复杂度 O((n - m + 1) * m)=O(mn)

因为要比较的字符串通常不会很长，所以BF算法的复杂度通常满足要求。

RK算法 Rabin Karp(两个人名)

思路: 对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小，如果哈希值相等，则说明找到了子串。设计的哈希函数为：假设字符串的字符集中只包含K个字符，则一个字符串可以看做是一个K进制的数字，将它转化为10进制数字，就是字符串的哈希值。这样就不存在哈希值冲突的场景，而且从当前子串的哈希值可以很容易计算出下一个子串的哈希值。

时间复杂度 O(n)。如果设计的哈希函数有冲突，最坏的时间复杂度是 O(mn)

BM算法 Boyer Moore

思路：BF算法中，当模式串和主串不匹配时，模式串向后滑动1个字符再与主串比较。BM则是尽可能向后多滑动几位。

坏字符规则 bad character rule

- 将模式串从后往前，和主串中的子串比较。当遇到不匹配的字符A
    - A在模式串中不存在：将模式串滑动到A后面，再和主串的子串进行比较。
    - A在模式串中存在：找到模式串中下标最大的A，将该A与主串中A下标对其，再和主串中的子串比较。

缺点：模式串可能会向前滑动，如，主串是 aaaaaaaaaa，模式串是 baaa

好后缀规则 good suffix rule

- 将模式串从后往前，和主串中的子串比较。当遇到不匹配的字符A时，模式串中在A后面和主串匹配的后缀子串是u
- 在模式串中，从后往前查找子串u
    - 找到，则将找到的u和主串中的u对齐，然后继续比较
    - 没找到
        - u的后缀子串v，和模式串的前缀子串v能够互相匹配：将模式串的v和主串的v对齐，然后继续比较
        - u的后缀子串和模式串的前缀子串没有互相匹配的：将模式串移动到u的后面，然后继续比较

好后缀的计算方法

辅助数组：

suffix[m] 下标表示后缀长度，值用来存储模式串中和该后缀匹配的子串u的起始下标

prefix[m] 下标表示后缀长度，值表示是否是模式串的前缀

```
下标       0   1   2   3   4   5
模式串   | c | a | b | c | a | b |
suffix  |   | 2 | 1 | 0 | -1| -1|
后缀子串 |   |b |ab|cab|bcab|abcab|
prefix  |   | f | f | t | f | f |
```

BM算法：当遇到不匹配字符时，分别使用坏字符规则和好后缀规则，计算出需要移动的位数，哪个大，则采取哪种移动方式。

空间复杂度：O(m)

时间复杂度：O(m^2)

任务：实现BM算法

KMP算法 D.E.Knuth J.H.Morris V.R.Pratt

原理：模式串和主串对比，当遇到坏字符时，模式串往后移动尽可能多的位置。移动的原理：在坏字符之前的模式串子串为v，找到v的最长的和v的前缀u匹配的后缀子串u’，然后将u和v向后对齐。

辅助数组

next[m]: 下标表示v的长度，值表示前缀u的最后一位的下标。

```
下标       0   1   2   3   4   5   6
模式串   | a | b | a | b | a | c | d |
suffix  | -1| -1| 0 | 1 | 2 | -1| -1|
```

任务：实现KMP算法

## Trie 树（字典树）

应用场景：搜索引擎的联想词

目标：在一组字符串集合中，快速查找前缀是xxx的字符串集合。

原理：利用字符串之间的公共前缀，将重复的前缀合并在一起。

如： how, hi, her, hello, so, see 构成的 trie 树如下，依次将字符串插入到树中。

```
                /
        _________________
        |               |
        h               s
    _________         ______
    |   |   |        |      |
    e   i   o        e      o
   ___      _        _
  |   |     |        |  
  l   r     w        e
  l
  o
```

Trie 树的存储

```java
class TrieNode {
    char data;
    TrieNode children[26]; // 下标0表示存储了字符a的TrieNode，依次类推
    boolean isEndingChar; // 是否是最后一个字符
}
```

任务：构建trie树

查找时间复杂度：O(k) k是查找的字符串长度；构建树时间复杂度：O(n) n是所有字符串的长度和。

缺点：耗内存。

改进点：可以将 `TrieNode children[26]` 换成有序数组、跳表、散列表、红黑树。但是查询、插入效率会变低。

## AC 自动机

目标：实现字符串和多模式串的匹配，匹配到一个模式串，就认为匹配成功。

应用场景：将文章中的敏感词变成 ***，其中敏感词有很多个。

实现原理：将多个模式串构成一个trie树，在trie树中构建类似KMP算法的next指针。如某节点的失败指针(next指针)，指向了该节点到root节点所代表的字符串的能和后缀匹配的最长前缀字符串的结尾节点。

```java
// tire 树节点
class AcNode {
    char data;
    AcNode[] children;
    boolean isEndingChar;
    AcNode next; // fail 失败指针
}
```

构建失败指针：

- 根节点的fail指针是null
- 根节点的孩子（第一层节点）的fail指针为root。
- 拿到第二层节点A，和它的父节点的fail指针指向的节点B的孩子节点C。对比这两个节点的data是否相同
    - 是，则A的fail指针指向C节点
    - 否，拿到B的fail节点指向的节点的孩子节点D，对比A和D，重复第二步
- 如果fail指针是null，则A节点的fail指针指向根节点root。

时间复杂度：O(k * h) k是节点数，h是树高

主串匹配模式串：

- 主串的字符依次和trie匹配
    - 匹配失败，移动到该节点的fail指针处，继续匹配
        - 匹配的fail指针是null，则从root节点开始重新匹配
    - 匹配成功，查看该节点及该节点的失败指针指向的节点是不是模式串的最后一个节点
        - 是，则表示有模式串匹配成功
        - 否，则继续匹配

时间复杂度：O(n * h) n是主串字符个数，h是树高

任务：实现一个AC自动机，将文章中的敏感词变成***

## 贪心算法 greedy algorithm

可以用到贪心算法的场景：

- 针对一组数据，定义了限制值和期望值，希望从中选择几个数据，在满足限制值的情况下，期望值最大。
- 每次选择，不会影响后面的选择。
- 选择数据的标准：对限制值同等贡献的情况下，对期望值的贡献最大
- 验证贪心算法的正确性（一般是显而易见的，或者被人证明过的，或者举几个例子能看出贪心算法得出的是正确结果。严格数学证明比较困难）

例子：

1. 有m个糖果，n个孩子，m < n。每个糖果的重量是 s1, s2, ..., sm。每个孩子对糖果的需求是 g1, g2, ..., gn。求：如果尽可能满足最多孩子。

2. 区间覆盖，有n个区间，起始点分别是[l1, r2], [l2, r2],....,[ln, rn] 从n个区间中选择出一部分区间，满足两两不相交，最多能选出多少个区间。

3. 霍夫曼编码。有一个文件，如何将这个文件压缩到最小？答：查找文件所用的字符，并按照频率排序。对字符进行变长编码，高频字符用短编码，低频字符用长编码。编码要保证互不为前缀（霍夫曼树中的字符频率，只能是叶子节点，这样就保证了编码后互不为前缀），这样解码时，最长前缀匹配到的编码，就是对应的字符。

## 分治算法

原理：分而治之，将问题分解成n个规模较小，且结构和原问题相似的子问题，递归解决这些子问题，再合并结果，就得到原问题的解。

关键点：分解、求解子问题、合并子问题的结果。当子问题足够小时，可以直接求解。

例子

1. 求解一组数据的逆序对。答：将数据分成前后两半A1和A2，分别计算A1和A2的逆序对，再计算A1和A2间的逆序对，最后将3者相加。
    - 分解：将数据分成前后两半A1和A2，分别计算A1和A2的逆序对。
    - 最小子问题求解：当一组数据中只有2个数据的时候，可以直接得出逆序对是0或者1。
    - 合并：将2组数据分别排序，然后合并成1组有序数据的时候。当选择的数据p来自后半组A2，则前半组A1中剩余的数据都能和p构成逆序对。

2. 二维平面上有n个点，如何快速求出两个聚鑫最近的点对？
3. 有两个 N * N 的矩阵AB，如果快速求解2个矩阵的乘积 C = A * B

## 回溯算法

原理：枚举所有选择，从中选择一条最优的。第一步有n个路径，随机选择一个，当走到尽头的时候，回退到上一步，选择其他路径，重复这个步骤，直到回退到原点时，所有路径都已选择完毕。（rainy：有点像图的深度优先遍历）

例子

1. 八皇后问题：在 8 * 8 的棋盘中放入 8 个棋子，要求每个棋子所在的行、列、对角线都不能有另一个棋子。

2. 0-1背包：一个背包，总承重是Wkg，有n个物品，重量不等，不可分割。在不超过背包承重的条件下，如何让背包中物品的总重量最大？答：每个物品有2种选择，装进去或者不装进去。采用回溯算法遍历这 2^n 个可能性，选出重量最大的一个出来。

3. 正则表达式：假设正则表达式中只有2种通配符 * 和 ? 。通配符就表示岔路口，* 有 n - m 种可能性，n是要匹配的字符串的长度，m是通配符所在的下标；? 有 2 种可能性。遇到通配符时，选择其中一种可能性，如果匹配不成功，则回溯到通配符的位置，选择下一种可能性再进行匹配。

4. 图的着色、旅行商问题、数独、全排列

## 动态规划

使用场景：求解最优解。多阶段决策最优解模型。要满足3个特征：最优子结构（可以通过子问题的最优解，推导出问题的最优解。即下一个状态的最优解，可以由前一个状态推导出）、无后效性、重复子问题。

原理：也是遍历所有可能的情况，然后选出其中最优的。不同的是，某些情况中的某几步可能在之前已经计算过，可以复用之前的计算结果。之前的计算结果存在表(状态转移矩阵)中。转移矩阵的行存储的结果，即在一步步的状态下，会发生转移的变量；列表示走到最后经过的状态，所以最后一列是最后所有情况的最终结果。

因为动态规划也是遍历所有结果，所以可以用动态规划求解的，都可以用回溯算法求解。

例子：

- 0-1 背包问题：对于一组重量不同、不可分割的物品n，我们选择其中一些装入背包，在满足背包容量w的前提下，背包中物品总重量的最大值是多少？

为什么叫 0-1 背包问题？答：因为放入背包中的物品有2种状态，要么不放入背包(0)，要么放入背包(1)

状态有哪些？答：等于物品数，每个物品的放入或不放入背包的选择，就是一次状态。

发生转移的变量是哪个？答：背包中物品的重量。变量的范围是 [0, 背包容量]

状态转移矩阵怎么求？答：矩阵 matrix[][] 行=物品数，列=背包容量。第一个物品有2个选择，故第一行有2个值：`matrix[0][0] = true; matrix[0][w1] = true`，其他为 false。w1是物品的重量。第二行，物品2不放入背包时 `matrix[1][0] = true; matrix[1][w1] = true;`，物品2放入背包时 `matrix[1][w2]=true; matrix[1][w1+w2]=true`，依次类推。

怎么得出总重量的最大值？答：最后一行，从后往前数，第一个true对应的列值，即为总重量的最大值。

时间复杂度：O(nw)

状态转移矩阵可以优化吗？答：如果每次一状态，转移的变量只增或只减或只保留最大或最小的某个值，则可以省略状态的记录，只记录变量的转移。如可以将转移矩阵变成1行。每次状态的结果在上次的结果上叠加。

- 0-1 背包升级：在原来的基础上，每个物品有不同的价值，在满足背包容量w的基础上，求背包中物品总价值的最大值

状态和转移的变量都没有变，区别是状态转移矩阵中，每行存储的是物品的价值。

怎么得出总价值的最大值？答：最后一行，选择总价值最大的一个。

状态转移矩阵可以优化吗？答：可以缩成一行，重量相同时，只记录总价值最大的值。

如何得知在总价值最大时，选择了哪些物品？答：总价值最大时，我们的已知条件是物品的总重量w和总价值v。假设第n个物品放入了背包，则`matrix[n - 2][w - wn] = v - vn` 如果不是，则表示第n个物品没有放入背包。依次类推，可以得知第x个物品有没有放入背包。

任务：写0-1背包的代码

- 有一个n * n 的矩阵 `w[n][n]` 存储的都是正整数，棋子从左上角开始，每一步只能向下或向右移动，移动到右下角的最短路径长度是多少？

状态：每走一步是1个状态，一共要走 2n-1 步。每一步都有2个选择

转移的变量：棋子的位置

状态转移矩阵：可以是 2n-1 个矩阵，对应每一个状态后棋子的位置。棋子位置处记录了路径长度。因为每一步棋子位置都会向右下方推进，到达重复位置时，只需要记录最小的路径值即可，所以可以简化为一个矩阵，矩阵中的值代表棋子到达该位置时的最小路径长度。

动态转移方程：类似递归，转移方程为 `minDist[i][j] = w[i][j] + min(minDist[i - 1][j], minDist[i][j - 1]`

综合（rainy: 这个是不是只能用回溯算法求解？）
- 硬币找零：有n种不同面额的硬币，面额分别为 v1, v2, ... vn，要支付w元，求最少需要多少个硬币

- 搜索引擎的纠错功能（有时间重看）

编辑距离：将一个字符串转化成另一个字符串，需要的最少编辑次数。（rainy: 可是下面2个感觉都表示把2个字符串统一成同一个字符串，没有把一个转成另一个）

计算编辑距离的方式：莱文斯坦距离（允许添加、删除、替换）（表示两个字符串差异大小）、最长公共子串长度（允许添加、删除）（表示两个字符串相似程度大小）

莱文斯坦距离（rainy：需要找对应的题做验证，我感觉他写的状态转移方程不对）

状态：每一个字符的处理

转移的变量：两两对比的字符

状态转移方程：

```
if (a[i] != b[j]) {
    minDist(i, j) = min(minDist(i-1, j) + 1, minDist(i, j-1) + 1, )
}
```

- 最长递增子序列长度：有n个不同的数字，求最长递增子序列长度。如 2, 9, 3, 6, 5, 1, 7 最长递增子序列是 2, 3, 5, 7 长度是4。

## 拓扑排序

问题：在一个无环的有向图中，根据依赖关系输出节点。没有依赖的节点先输出，依赖节点都被输出的节点后输出。其中A指向B，表示A需要先执行，然后B才能执行，即B依赖A。

解决方案

1. Kahn算法：利用节点A的入度值（指向A的节点数）。入度值为0的表示没有依赖。
    1. 计算出所有节点的入度
    2. 打印出所有入度为0的节点；将该节点指向的所有节点的入度-1。如果入度降为0则打印节点，同时重复本步骤，直到节点打印完。
2. 利用深度优先遍历。
    1. 计算出逆邻接矩阵。此时的图表示依赖关系。
    2. 深度优先遍历，遍历完子树后，最后打印自己

时间复杂度 O(V + E)

如何检查是否有环？

Kahn算法输出的顶点数小于总数；

任务：拓扑排序

## 最短路径

场景：有向加权图，求顶点A到顶点B的最短路径。

原理：Dijkstra 算法：整一个数组V，长度是顶点数，记录顶点A到其他顶点的最短路径长度。整一个数组Path，记录到达某顶点的上一个顶点。初始时A到自己是0，到其他顶点都是无穷大。遍历A指向的顶点x，如果A到x的距离比数组V中记录的小，则更新数组V。将x入队，然后出队，遍历x指向的顶点y，如果 `V[x] + dist(x, y) < V[y]` 则 `V[y] = V[x] + dist(x, y); Path[y] = x`。重复这个过程，直到遍历完所有的顶点。则 `V[b]` 即为所求。此时数组V中存储的是A到其他顶点的最短路径长度，Path存的是最短路径。

复杂度：O(V*V) 适用图比较密集的场景 （rainy: 重新看）

优化：使用优先级度列来存储数组V，每次出队的顶点是当前到A的路径最短的顶点。

复杂度：O(E*logV)  （rainy: 重新看）

例子

- 求地图中2点的最短距离，地图很大。答：先求地图主干的最短距离，然后再缩小到某个主干区域内，求最短距离。如求北京到广东的最短距离，先求北京到广东需要途径的省，如河北省等。再求北京到河北的最短距离。最后整合起来。

- 一个句子有n个单词组成，通过翻译每个单词来完成句子的翻译。每个单词有m个解释，得分分别为x1, x2...。求得分最高的k个句子。

答：先将得分最高的句子放入优先级队列；然后取出，依次替换其中的某个单词为下一个翻译，再放入队列；在优先级队列中取出得分最高的句子，然后依次替换句子中的单词为下一个翻译；重复这个过程，直到获得k个句子。

复杂度：O(k * n * log(kn))

其他最短路径算法：Belford算法、Floyd算法。

任务：实现最短路径算法

## 位图

场景：在内存比较小，又有大量数据需要判断是否存在。

原理：使用1bit来表示一个boolean值，0表示false，1表示true。使用一一映射的方式将数据和bit的索引（下标）关联起来，比如有1到1亿的整数，第k个整数和bit索引的映射为 `char[] bytes;  boolean exist = bytes[k / 16] & (1 << k%16)`

缺点：数据范围大，则空间浪费大

布隆过滤器

原理：使用K个哈希函数，对同一个数字求哈希值，得到K个不同的哈希值。set: 将K个哈希值对应的bit设置为1。get: 获取K个哈希值对应的bit，如果都为1，则说明该数字存在；如果有一个不为1，则说明数字不存在。

缺点：某数字不存在，但可能将其判定为存在。但当位图较大，哈希函数选择合理时，发生的概率比较小。

应用场景：如搜索引擎的爬虫抓取网页，判断网页是否抓取过。即使误判为抓取过，少一个网页对总量影响有限。

任务：实现位图，查看BitSet代码

## 概率统计

场景：过滤垃圾短信

方案一：基于黑名单过滤。来自某个号码的短信判定为垃圾短信

方案二：基于规则的过滤。短信中包含某些单词，则判定为垃圾短信

方案三：基于概率的过滤。计算短信是垃圾短信的概率。

原理：将一条短信M拆分成n个单词 w1, w2, ... wn。

利用贝叶斯算法 P(A|B) = P(B|A) * P(A) / P(B)。

则 P(M是垃圾短信|w1-n同时出现在短信中) = P(w1-n同时出现在短信中|M是垃圾短信) * P(M是垃圾短信) / P(w1-n同时出现在短信中)

因为 P(AB) = P(A) * P(B)，所以 P(w1-n同时出现在短信中|M是垃圾短信) = P(w1在M中|M是垃圾短信) * P(w2在M中|M是垃圾短信) * ... * P(wn在M中|M是垃圾短信)

因为样本少时，P(w1-n同时出现在短信中) 无法计算出，可以计算 P(M是垃圾短信|w1-n同时出现在短信中)/P(M不是垃圾短信|w1-n同时出现在短信中)，如果得出的数值很大，则M是垃圾短信。

## 向量空间

场景：推荐符合你口味的歌曲

算法：1. 找到和你口味相似的用户，把他们爱听的歌曲推荐给你；2. 找出你喜爱的歌曲特征，把具有相同特征的歌曲推荐给你。

1. 找到和你口味相似的用户，把他们爱听的歌曲推荐给你

获取你的歌曲列表，对每首歌计算出你的喜爱度。喜爱度通过行为计算，如单曲循环+5分，分享+4分，收藏+3分等。

获取和你有共同歌曲的用户，计算出他们对这些歌的喜爱度。

计算他们的喜爱度向量和你的喜爱度向量的距离，距离越近，口味越相似。

向量 x(x1, x2, ... xn) 和向量 y(y1, y2, ... yn) 之间的距离 d = 根号((x1 - y1)^2 + (x2-y2)^2 + .... + (xn - yn)^2)

这个距离称为欧几里得距离

2. 找出你喜爱的歌曲特征，把具有相同特征的歌曲推荐给你

获取你喜爱的一首歌曲A，找出听了这首歌的用户，并计算出每个用户对这首歌的喜爱度，得到歌曲的向量(用户1的喜爱度，用户2的喜爱度... 用户n的喜爱度)。获得其他歌曲的向量，并计算与A的距离，距离越近，说明歌曲越相似。

## B+ 树（插入、删除、构建需要再找材料看一遍）

场景：数据库中，根据id=xx或id>xxx来查询数据，可以通过构建索引来完成。要求查询尽可能快，额外占用的空间尽可能少。

原理：将数据库排好序，并用单链表连起来。在这个排好序的数据上建索引，使用B+树的数据结构。索引节点存储在磁盘上，则不消耗内存，但是查询磁盘的操作非常耗时。因此索引的树高越低，查询磁盘的次数越少，耗费的时间越少。而B+树每个节点存储的索引越多，树高越低。

因为B+树的节点是存储在磁盘上的，所以索引+下一个结点的地址=一页，能保证只查一次数据。

引入索引会导致插入和删除变慢，因为这2个操作都需要重新构建索引。

跳表和B+树的原理有点像。

B+树的特点(m是分叉数)

- 每个节点中子节点个数不能超过 m，也不能少于 m/2 (分叉太少会导致树高变高，效率变慢)
- 根节点的子节点个数可以小于 m/2
- m叉树只存储索引，并不存储数据
- 通过链表将叶子节点串联在一起，这样可以方便按照区间查找
- 根节点被存储在内存中，其他节点存储在磁盘中

## A*搜索

场景：游戏中的自动寻路。

使用 Dijkstra 算法，可能会造成绕路。改进 Dijkstra 算法中节点A到节点B的最短路径的算法

启发函数(heuristic function): h(i) 顶点x到目标顶点D的距离。可以用曼哈顿距离表示 h(i) =|x1-x2| + |y1-y2|

估价函数(evaluation function): f(i) = g(i) + h(i); g(i) 顶点x到开始顶点A的最短距离

队列中按照 f(i) 最小出队。

其他启发式搜索算法(Heuristically Search Algorithm): IDA*算法、蚁群算法、遗传算法、模拟退火算法。

























































